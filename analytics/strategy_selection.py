import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.stats import rankdata
from sgmtradingcore.analytics.overfitting_metrics import compute_metrics, dsr

valid_metrics = ['sharpe', 'annualised_sharpe', 'sortino', 'annualised_sortino']


class StrategySelector(object):
    """Class representing a strategy selection method.

    This class is meant to be used to implement different criteria of selecting the best strategy
    from a pool of candidates and to implement diagnostic plots on the selected strategies.
    """

    def __init__(self):
        self.best_strategy = None
        self.strategy_ordering = None

    def select_best_strategy(self):
        """Method to select the best strategy among the different candidates
        """
        raise NotImplementedError('Implement this method in a subclass!')

    def diagnostic_plots(self):
        """Method to generate diagnostic plots regarding the selected strategy
        and/or the selection process itself
        """
        raise NotImplementedError('Implement this method in a subclass!')


class NaiveStrategySelector(StrategySelector):
    """Class to implement a naive strategy selection method.

    The naive method consists in choosing the strategy with the highest selected metric in the
    backtest window. This class takes as input a matrix of returns generated by all the candidates,
    the metric one wants to use and the number of days spanned by the returns.

    Parameters
    ----------
    df_returns: DataFrame, shape (n_returns, n_strategies)
        Returns generated by all the candidates strategies. Each column
        represents a different strategy. It can contain Nans.

    metric: str, optional, default="annualised_sharpe"
        name of the metric to be computed or function to compute it.
        Possible values are ["sharpe", "annualised_sharpe", "sortino",
        "annualised_sortino"].

    n_days: int, optional (default=365)
        Number of days spanned by the returns. It is used in case
        metrics is annualised_sharpe or annualised_sortino

    Other attributes
    ----------------
    best_strategy: int or str
        Column of the self._returns DataFrame corresponding to the best
        strategy
    """

    def __init__(self, df_returns, metric="annualised_sharpe", n_days=365):

        super(NaiveStrategySelector, self).__init__()

        if not isinstance(df_returns, pd.DataFrame):
            raise ValueError('Expected a DataFrame, got a {} instead!'.format(type(df_returns)))

        if metric not in ['sharpe', 'sortino', 'annualised_sharpe', 'annualised_sortino']:
            raise ValueError('Unkown metric {}! Choose one among {}'.format(
                metric, ', '.join(valid_metrics)))

        self._returns = df_returns
        self._metric = metric
        self._n_days = n_days

    def select_best_strategy(self, n_best=1):
        """Method to select the best strategy.

        The best strategy is defined as the one maximizing the selected metric.

        Parameters
        ----------
        n_best: int, optional (default=1)
            specifies what strategy we actually want to retrieve. n_best=1 means the
            best, n_best=2 the second best and so on.

        Returns
        -------
        best_strategy: str or int
            Column of the self._returns DataFrame corresponding to the best
            strategy
        """
        all_metrics = compute_metrics(self._returns, metric=self._metric,
                                      n_days=self._n_days)

        ordering = all_metrics.argsort()

        best_strategy = ordering[-1]

        self.best_strategy = self._returns.columns[best_strategy]
        self.strategy_ordering = [self._returns.columns[idx] for idx in ordering]

        return self.strategy_ordering[-n_best]

    def _basic_plots(self, ax_matrix, lower_limit_quantile, upper_limit_quantile, max_n=1):
        """Method to produce some plots regarding the selected strategy that are shared by different
        sub-classes.

        This method generates four plots:
        * upper left corner: cumulative return of the selected strategies
        * upper right corner: series of the returns of the best strategy
        * lower left corner: distribution of the returns of the selected strategies
        * lower right corner: quantile plot of the returns of the selected strategies

        Parameters
        ---------
        ax_matrix: 2d array of ax objects
            it must have at least two rows and two columns to accomodate the four plots described
            above.
        lower_limit_quantile: float in (0, 1)
            minimum quantile considered in the distribution plot. It is used to avoid that extreme
            returns make the distribution plot uninformative.
        upper_limit_quantile: float in (0, 1)
            maximum quantile considered in the distribution plot. It is used to avoid that extreme
            returns make the distribution plot uninformative.
        max_n: int, optional (default=1)
            it selects how many strategies we want to include in the diagnostic. if max_n=1, only
            the best strategy is included, if max_n=2 the best two and so on.

        """

        if isinstance(self.best_strategy, list):
            strategy_idx = self.best_strategy[0]
        else:
            strategy_idx = self.best_strategy


        best_strategy_returns = self._returns[strategy_idx]
        best_strategy_returns_filled = best_strategy_returns.fillna(0)
        cumsum_series = best_strategy_returns_filled.cumsum()
        ax_matrix[0, 0].plot(pd.to_datetime(cumsum_series.index), cumsum_series.values,
                             label='best')
        if max_n > 1:
            other_strategies_returns = []
            for idx in range(-2, -max_n - 1, -1):
                n_strategy_idx = self.strategy_ordering[idx]
                strategy_returns = self._returns[n_strategy_idx]
                other_strategies_returns.append(strategy_returns)
                strategy_returns_filled = strategy_returns.fillna(0)
                n_cum_series = strategy_returns_filled.cumsum()
                ax_matrix[0, 0].plot(pd.to_datetime(n_cum_series.index), n_cum_series.values,
                                     label='{}th best'.format(-idx))
                ax_matrix[0, 0].legend(fontsize=12)
        ax_matrix[0, 0].set_title('Best strategy cumulative return', fontsize=14)
        ax_matrix[0, 1].plot(pd.to_datetime(best_strategy_returns_filled.index),
                             best_strategy_returns_filled.values)
        ax_matrix[0, 1].set_title('Best strategy returns', fontsize=14)
        lower_limit = best_strategy_returns.quantile(lower_limit_quantile)
        upper_limit = best_strategy_returns.quantile(upper_limit_quantile)
        returns_to_plot = best_strategy_returns[(best_strategy_returns <= upper_limit) &
                                                (best_strategy_returns >= lower_limit)]
        sns.distplot(returns_to_plot, ax=ax_matrix[1, 0], label='best')
        if max_n > 1:
            for i, returns in enumerate(other_strategies_returns):
                lower_limit = returns.quantile(lower_limit_quantile)
                upper_limit = returns.quantile(upper_limit_quantile)
                returns_to_plot = returns[(returns <= upper_limit) &
                                          (returns >= lower_limit)]
                sns.distplot(returns_to_plot, ax=ax_matrix[1, 0],
                             label='{}th best'.format(i + 2))
        ax_matrix[1, 0].legend(fontsize=12)
        ax_matrix[1, 0].set_title('Best strategy returns distribution', fontsize=14)
        quantiles_requested = np.arange(0.02, 1, 0.02)
        quantiles_values = best_strategy_returns.quantile(quantiles_requested)
        ax_matrix[1, 1].plot(quantiles_requested, quantiles_values, label='best')
        if max_n > 1:
            for i, returns in enumerate(other_strategies_returns):
                quantiles_values = returns.quantile(quantiles_requested)
                ax_matrix[1, 1].plot(quantiles_requested, quantiles_values,
                                     label='{}th best'.format(i + 2))
                ax_matrix[1, 1].legend(fontsize=12)
        ax_matrix[1, 1].set_title('Quantile plot of returns', fontsize=14)
        ax_matrix[1, 1].plot([0, 1], [0, 0], '--')

    def diagnostic_plots(self, figsize=(16, 10), lower_limit_quantile=.02,
                         upper_limit_quantile=.98, max_n=1):
        """Method to generate diagnostic plots on the selected strategy.

        This method generates and array of 4 plots. The description of the plots can be found in
        the docstring for the _basic_plots method.

        Arguments:
        ----------
        figsize: tuple of int, optional, default=(16, 10)
            Size of the generated figure
        lower_limit_quantile: float in (0, 1), optional (default=.02)
            minimum quantile considered in the distribution plot of the returns of the strategy.
            It is used to avoid that extreme returns make the distribution plot uninformative.
        upper_limit_quantile: float in (0, 1), optional (default=.98)
            maximum quantile considered in the distribution plot of the returns of the strategy. It
            is used to avoid that extreme returns make the distribution plot uninformative.
        max_n: int, optional (default=1)
            it selects how many strategies we want to include in the diagnostic. if max_n=1, only
            the best strategy is included, if max_n=2 the best two and so on.
        """

        if self.best_strategy is None:
            raise ValueError("""Determine the best strategy before calling this
                                method!""")

        _, axs = plt.subplots(2, 2, figsize=figsize)

        self._basic_plots(axs, lower_limit_quantile, upper_limit_quantile, max_n=max_n)


class ReturnsBootstrappingSelector(NaiveStrategySelector):
    """Class to implement a strategy selection method based on bootstrapping the returns of the
    selected strategy.

    The selection method consists in sampling with replacement (bootstrapping) the returns of each
    of the candidate strategy and then compute the mean of the selected metric. The strategy with
    the highest mean of the selected metics is the chosen one. This class takes as input a matrix of
    returns generated by all the candidates, the metric one wants to use, the number of days spanned
    by the returns, the number of bootstrap samples we want to extract and the seed of the random
    generator

    Parameters
    ----------
    df_returns: DataFrame, shape (n_returns, n_strategies)
        Returns generated by all the candidates strategies. Each column
        represents a different strategy. It can contain Nans.

    metric: str, optional, default="annualised_sharpe"
        name of the metric to be computed or function to compute it.
        Possible values are ["sharpe", "annualised_sharpe", "sortino",
        "annualised_sortino"].

    n_days: int, optional (default=365)
        number of days spanned by the returns. It is used in case
        metrics is annualised_sharpe or annualised_sortino

    n_bootstraps : int, optional (default=500)
        number of bootstrapping iterations, i.e. number of bootstrapped
        strategies to generate for each of the candidate strategy. Each
        bootstrapped strategy has the same number of returns as the original one.

    seed: int, optional (default=1234)
        seed for the ranom generator

    aggregation_method: str, optional (default=mean)
        it establishes how to aggregate the metric estimates coming from the different
        bootstramp samples. It can be either "mean" or "median"

    Other attributes
    ----------------
    best_strategy: int or str
        Column of the self._returns DataFrame corresponding to the best
         strategy
    aggregated_metrics: numpy array shape(n_strategies,)
        mean or median value (depending on the value of aggregation_method) of the chosen metric
        per each strategy computed using bootstrapping
    """

    def __init__(self, df_returns, metric="annualised_sharpe", n_days=365, bootstrap_samples=500,
                 seed=1234, aggregation_method="mean"):

        super(ReturnsBootstrappingSelector, self).__init__(df_returns=df_returns, metric=metric,
                                                           n_days=n_days)

        if not isinstance(bootstrap_samples, int):
            raise ValueError('Expected integer for bootstrap_samples, got {} instead'.format(
                type(bootstrap_samples)))

        self._bootstrap_samples = bootstrap_samples
        self._seed = seed
        self.aggregated_metrics = None
        self._aggregation_method = aggregation_method

    def select_best_strategy(self, n_best=1):
        """Method to select the best strategy.

        The best strategy is defined as the one with the highest mean of the selected metrics,
        computing by bootstrapping the returns of each candidate strategy.

        Parameters
        ----------
        n_best: int, optional (default=1)
            specifies what strategy we actually want to retrieve. n_best=1 means the
            best, n_best=2 the second best and so on.

        Returns
        -------
        best_strategy: str or int
            Column of the self._returns DataFrame corresponding to the best
            strategy
        """

        self.aggregated_metrics = self._returns.apply(
            lambda col: self._get_bootstrap_aggregate(col, self._bootstrap_samples))

        min_value = self.aggregated_metrics.min()
        ordering = self.aggregated_metrics.fillna(min_value - 0.1).values.argsort()

        best_aggregate = ordering[-1]

        self.best_strategy = self._returns.columns[best_aggregate]
        self.strategy_ordering = [self._returns.columns[idx] for idx in ordering]

        return self.strategy_ordering[-n_best]

    def _get_bootstrap_aggregate(self, return_series, bootstrap_samples, aggregation_method="mean"):
        """Method to compute the mean or median by bootstrapping
        """

        idx = return_series.index.values
        rnd = np.random.RandomState(self._seed)
        choice = rnd.choice(idx, len(return_series) * bootstrap_samples)
        bootstrap_matrix = return_series.loc[choice].values.reshape((len(return_series),
                                                                     bootstrap_samples))
        metrics = compute_metrics(bootstrap_matrix, metric=self._metric, n_days=self._n_days)

        if aggregation_method == "mean":
            aggregate = metrics.mean()
        elif aggregation_method == "median":
            aggregate = metrics.median()

        return aggregate

    def diagnostic_plots(self, figsize=(18, 16), lower_limit_quantile=.2, upper_limit_quantile=.98,
                         max_n=1):
        """Method to generate diagnostic plots on the selected strategy.

        This method generates a 3x2 array of plots. The first two rows are occupied by the plots
        generate by the _basic_plots method. The left plot of the third row contains the
        distribution plot of the aggregated value of the metric computed by bootstrapping, while the
        right plot of the third row contains the plot of the aggregated value of the metric
        computed by bootstrapping for each strategy with the best 5 strategies highlighted.

        ----------
        figsize: tuple of int, optional, default=(16, 10)
            Size of the generated figure
        lower_limit_quantile: float in (0, 1), optional (default=.02)
            minimum quantile considered in the distribution plot of the returns of the strategy.
            It is used to avoid that extreme returns make the distribution plot uninformative.
        upper_limit_quantile: float in (0, 1)
            maximum quantile considered in the distribution plot of the returns of the strategy. It
            is used to avoid that extremereturns make the distribution plot uninformative.
        max_n: int, optional (default=1)
            it selects how many strategies we want to include in the diagnostic. if max_n=1, only
            the best strategy is included, if max_n=2 the best two and so on.
        """

        if self.best_strategy is None:
            raise ValueError("""Determine the best strategy before calling this
                                method!""")

        _, axs = plt.subplots(3, 2, figsize=figsize)

        self._basic_plots(axs, lower_limit_quantile, upper_limit_quantile, max_n=max_n)

        sns.distplot(self.aggregated_metrics.dropna(), ax=axs[2, 0])
        axs[2, 0].set_title('Distribution of {} metrics from bootstrap'.format(
            self._aggregation_method), fontsize=14)
        axs[2, 1].plot(self.aggregated_metrics.values, '.')
        ordering = self.aggregated_metrics.argsort()
        best_strategies = []
        for rank in range(-5, 0, 1):
            idx = ordering[rank]
            value = self.aggregated_metrics[idx]
            best_strategies.append(idx)
            axs[2, 1].vlines(idx, 0, value, linestyle='dotted', colors='r', alpha=0.7, lw=1.2)
        axs[2, 1].set_title('Aggregated metric of each strategy', fontsize=14)


class SlicingSelector(NaiveStrategySelector):
    """Class to implement a strategy selection method based on slicing the backtest period and
    aggregating the performance of each strategy in each of the slices.

    First the backtest period is split in a certain number of chunks. Then, in each of the chunks
    the strategies whose performance is in a certain top quantile receive a score equal to their
    normalized rank, i.e 1 for the best strategy, 0.9 for the strategy that is beaten only by 10%
    of other strategies. The score coming from all the chunks are summed and the strategy with the
    highest score is selected.

    This class takes as input a matrix of returns generated by all the candidates, the metric one
    wants to use to evaluate the performance of each strategy, the number of days spanne by the
    returns, the number of splits, and the top quantile one wants to consider.`

    Parameters
    ---------
    df_returns: DataFrame, shape (n_returns, n_strategies)
        Returns generated by all the candidates strategies. Each column
        represents a different strategy. It can contain Nans.

    metric: str, optional, default="annualised_sharpe"
        name of the metric to be computed or function to compute it.
        Possible values are ["sharpe", "annualised_sharpe", "sortino",
        "annualised_sortino"].

    n_days: int, optional (default=1)
        number of years spanned by the returns. It is used in case
        metrics is annualised_sharpe or annualised_sortino

    splits: int, optional (default=5)
        number of chunks the backtest period is split into

    score_quantile_threshold: float in (0, 1), optional (default=0.1)
        Hard-thresholding parameter on the scores for each chunk.
        For example if quantile_threshold=0.1, for each chunk 90% of the strategy scores are
        shrunk to zero: only the best 10% of the strategies receive a non-zero score.

    Other attributes
    ----------------
    best_strategy: int or str
        Column of the self._returns DataFrame corresponding to the best
         strategy
    _rank_series: numpy array, shape: (n_strategies,)
        array storing the score coming from the process
    _count_series: numpy array, shape: (n_strategies,)
        array storing the number of times each strategy finished in the desired top quantile,
        independently on its exact rank
    """

    def __init__(self, df_returns, metric="annualised_sharpe", splits=5, best_quantile=0.1,
                 n_days=365):

        super(SlicingSelector, self).__init__(df_returns, metric, n_days)

        if not isinstance(splits, int):
            raise ValueError('Expected integer for splits, got {} instead'.format(type(splits)))

        if best_quantile < 0 or best_quantile > 1:
            raise ValueError('best_quantile must be between 0 and 1!')

        self._splits = splits
        self._best_quantile = best_quantile
        self._index = self._returns.index
        self._rank_series = np.zeros(len(self._returns.columns))
        self._count_series = np.zeros(len(self._returns.columns))
        self._rank_mean = np.zeros(len(self._returns.columns))
        self._rank_std = np.zeros(len(self._returns.columns))

    def select_best_strategy(self, n_best=1):
        """Method to select the best strategy.

        The best strategy is defined as the one with the highest aggregate rank score in all the
        chunks of the backtest period. See the docstring of the class for more information

        Parameters
        ----------
        n_best: int, optional (default=1)
            specifies what strategy we actually want to retrieve. n_best=1 means the
            best, n_best=2 the second best and so on.

        Returns
        -------
        best_strategy: str or int
            Column of the self._returns DataFrame corresponding to the best
            strategy
        """

        n_strategies = self._returns.shape[1]

        limit_position = int((1 - self._best_quantile) * n_strategies)

        count = 0
        print '\n'
        for idx in np.array_split(self._index, self._splits):
            count += 1
            split_returns = self._returns.loc[idx]
            split_n_days = float(self._n_days) * len(split_returns) / len(self._returns)
            metrics = compute_metrics(split_returns, self._metric, split_n_days)
            rank = rankdata(np.nan_to_num(metrics))
            good_metrics = (rank >= limit_position + 1)
            rank[~good_metrics] = 0
            self._rank_series += rank / float(n_strategies)
            self._count_series += good_metrics.astype('int')
            old_means = np.copy(self._rank_mean[:])
            self._rank_mean += (rank / float(n_strategies) - self._rank_mean) / count
            self._rank_std += ((rank / float(n_strategies) - old_means) *
                               (rank / float(n_strategies) - self._rank_mean))

        self._rank_std /= (self._splits - 1)
        self._rank_std = np.sqrt(self._rank_std)
        ordering = self._rank_series.argsort()
        best_idx = ordering[-1]

        self.strategy_ordering = [self._returns.columns[idx] for idx in ordering]
        self.best_strategy = self._returns.columns[best_idx]

        return self.strategy_ordering[-n_best]

    def diagnostic_plots(self, figsize=(18, 24), lower_limit_quantile=.02, upper_limit_quantile=.98,
                         max_n=1):
        """Method to generate diagnostic plots on the selected strategy.

        This method generates a 4x2 array of plots. The first two rows are occupied by the plots
        generate by the _basic_plots method. The left plot of the third row contains the plot
        of the rank score of each strategy with the best 5 strategies highlighted, while the right
        plot of the third row contains the plot of the number of times each strategy finished in
        the top quantile independently of its exact rank, with the best 5 strategies (according to
        the rank score) highlighted,. The left plot of the fourth row contains the plot of the ratio
        between the mean of the rank score and its variance across the different splits for each of
        the strategies, with the best 5 strategies (according to the rank score) highlighted. The
        right plot of the fourth row is a scatter plot of the standard deviation of the rank score
        vs its mean for all the strategies

        ----------
        figsize: tuple of int, optional, default=(16, 10)
            Size of the generated figure
        lower_limit_quantile: float in (0, 1), optional (default=.02)
            minimum quantile considered in the distribution plot of the returns of the strategy.
            It is used to avoid that extreme returns make the distribution plot uninformative.
        upper_limit_quantile: float in (0, 1)
            maximum quantile considered in the distribution plot of the returns of the strategy. It
            is used to avoid that extremereturns make the distribution plot uninformative.
        max_n: int, optional (default=1)
            it selects how many strategies we want to include in the diagnostic. if max_n=1, only
            the best strategy is included, if max_n=2 the best two and so on.
        """

        if self.best_strategy is None:
            raise ValueError("""Determine the best strategy before calling this
                                method!""")

        _, axs = plt.subplots(4, 2, figsize=figsize)

        self._basic_plots(axs, lower_limit_quantile, upper_limit_quantile, max_n=max_n)

        axs[2, 0].plot(self._rank_series, '.')
        ordering = self._rank_series.argsort()
        best_strategies = []
        for rank in range(-5, 0, 1):
            idx = ordering[rank]
            value = self._rank_series[idx]
            best_strategies.append(idx)
            axs[2, 0].vlines(idx, 0, value, linestyle='dotted', colors='r', alpha=0.7, lw=1.2)
        axs[2, 0].set_title('Rank score of strategies', fontsize=14)
        axs[2, 1].plot(self._count_series, '.')
        for idx in best_strategies:
            axs[2, 1].vlines(idx, 0, self._count_series[idx], linestyle='dotted', colors='r',
                             alpha=0.7, lw=1.2)
        axs[2, 1].set_title('Number of times in the top quantile', fontsize=14)
        axs[3, 0].plot(self._rank_mean / self._rank_std, '.')
        for idx in best_strategies:
            axs[3, 0].vlines(idx, 0, self._rank_mean[idx] / self._rank_std[idx], linestyle='dotted',
                             colors='r', alpha=0.7, lw=1.2)
        axs[3, 0].set_title('Mean rank score divided by std rank score of strategies across splits',
                            fontsize=14)
        axs[3, 1].plot(self._rank_mean, self._rank_std, '.')
        axs[3, 1].set_xlabel('Rank score mean')
        axs[3, 1].set_ylabel('Rank score std')
        axs[3, 1].set_title('Ranks score std vs Rank score mean', fontsize=14)


class DSRSelector(NaiveStrategySelector):
    """Class to implement a strategy selection method based on selecting the strategy with the
    highest deflated Sharpe ratio

    This class takes as input a matrix of returns generated by all the candidates, and optionally
    the number of trials, which can be passed if they are different to the numeber of columns of the
    returns matrix, due to the effect of correlations

    Parameters
    ---------
    df_returns: DataFrame, shape (n_returns, n_strategies)
        Returns generated by all the candidates strategies. Each column
        represents a different strategy. It can contain Nans.

    n_trials: int, optional (default=None)
        if not None, it specifies the effective number of independent trial. If None the number of
        independent trials is assumed to be equal to the number of columns of the returns matrix. It
        can be used to take into account the effect of correlations

    Other attributes
    ----------------
    best_strategy: int or str
        Column of the self._returns DataFrame corresponding to the best
         strategy

    """

    def __init__(self, df_returns, n_trials=None):

        super(DSRSelector, self).__init__(df_returns)

        self._ntrials = n_trials
        self._dsrs = None

    def select_best_strategy(self, n_best=1):
        """Method to select the best strategy.

        The best strategy is defined as the one with the highest deflated sharpe ratio

        Parameters
        ----------
        n_best: int, optional (default=1)
            specifies what strategy we actually want to retrieve. n_best=1 means the
            best, n_best=2 the second best and so on.

        Returns
        -------
        best_strategy: str or int
            Column of the self._returns DataFrame corresponding to the best
            strategy
        """


        self._dsrs = dsr(self._returns, n_trials=self._ntrials)

        ordering = self._dsrs.argsort()
        best_idx = ordering[-1]

        self.strategy_ordering = [self._returns.columns[idx] for idx in ordering]
        self.best_strategy = list(self._returns.columns)[best_idx]

        return self.strategy_ordering[-n_best]

    def diagnostic_plots(self, figsize=(18, 16), lower_limit_quantile=.02, upper_limit_quantile=.98,
                         max_n=1):
        """Method to generate diagnostic plots on the selected strategy.

        This method generates a 3x2 array of plots. The first two rows are occupied by the plots
        generate by the _basic_plots method. The left plot of the third row contains the
        plot of the DSRs for all the strategies with the best 5 strategies highlighted, while the
        right plot on the third row contains the quantile plot of the DSRs for all the strategies.

        ----------
        figsize: tuple of int, optional, default=(16, 10)
            Size of the generated figure
        lower_limit_quantile: float in (0, 1), optional (default=.02)
            minimum quantile considered in the distribution plot of the returns of the strategy.
            It is used to avoid that extreme returns make the distribution plot uninformative.
        upper_limit_quantile: float in (0, 1)
            maximum quantile considered in the distribution plot of the returns of the strategy. It
            is used to avoid that extremereturns make the distribution plot uninformative.
        max_n: int, optional (default=1)
            it selects how many strategies we want to include in the diagnostic. if max_n=1, only
            the best strategy is included, if max_n=2 the best two and so on.
        """

        _, axs = plt.subplots(3, 2, figsize=figsize)

        self._basic_plots(axs, lower_limit_quantile, upper_limit_quantile, max_n=max_n)

        axs[2, 0].plot(self._dsrs, '.')
        ordering = self._dsrs.argsort()
        best_strategies = []
        for rank in range(-5, 0, 1):
            idx = ordering[rank]
            value = self._dsrs[idx]
            best_strategies.append(idx)
            axs[2, 0].vlines(idx, 0, value, linestyle='dotted', colors='r', alpha=0.7, lw=1.2)
        axs[2, 0].set_title('DSR od each strategy', fontsize=14)
        quantiles_requested = np.arange(0.01, 1, 0.01)
        quantiles_values = pd.Series(self._dsrs).quantile(quantiles_requested)
        axs[2, 1].plot(quantiles_requested, quantiles_values)
        axs[2, 1].set_title('Quantiles of dsrs', fontsize=14)
