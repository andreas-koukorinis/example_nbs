"""
Created on 15 Apr 2014

Container types for passing messages around between the trading strategies,
exchange sim and creating market data subscriptions

@author: kostasc
"""
from datetime import timedelta
from dateutil import parser

from enum import IntEnum
from stratagemdataprocessing.parsing.common.stickers import generate_sticker, MarketScopes


# Can use BetStatus.SETTLED.name to convert it to string
class BetStatus(IntEnum):
    UNKNOWN = -1
    ERROR = 0  # doesn't map to the OMS, error generated by the framework, e.g. response timeout
    UNMATCHED = 1  # An order open in an exchange with no volume matched so far

    PARTIALLY_MATCHED = 2 # An order open in the exchange with some volume matched

    MATCHED = 3  # an order not completely matched which is no longer open in the exchange, is in status MATCHED
    CANCELLED = 4  # Cancelled, with no amount_matched (also if TTL expires)
    SETTLED = 5
    LAPSED = 6  # An order which was placed in an exchange is no longer valid and it has been cancelled by the exchange
    PARTIALLY_CANCELLED = 7  # If it's cancelled with 0 < amount_matched < size (also if TTL expires)
    VOIDED = 8
    REJECTED = 9  # Order has been placed and then rejected by the bookmaker

    # Order is pending in the time between sending it to the exchange and the time it get unmatched,
    # partially matched, matched or rejected.
    PENDING = 10

    FAILED = 11  # We tried to place the order but failed before placing it. Doesn't have a bet_id


# Bets with these statuses should be considered closed - i.e. their matched amounts etc can't change
CLOSED_BET_STATUSES = {BetStatus.ERROR, BetStatus.MATCHED, BetStatus.CANCELLED, BetStatus.SETTLED, BetStatus.LAPSED,
                       BetStatus.VOIDED, BetStatus.REJECTED, BetStatus.FAILED, BetStatus.PARTIALLY_CANCELLED}

# Bets with these statuses are not final, and the sizes can change
OPEN_BET_STATUSES = {BetStatus.UNKNOWN, BetStatus.UNMATCHED, BetStatus.PARTIALLY_MATCHED, BetStatus.PENDING}

# these status will never change
FINAL_BET_STATUSES = {BetStatus.ERROR, BetStatus.CANCELLED, BetStatus.SETTLED, BetStatus.LAPSED,
                      BetStatus.VOIDED, BetStatus.REJECTED, BetStatus.FAILED}


class BetTransactionType(IntEnum):
    UNKNOWN = -1
    PLACE = 0
    REPLACE = 1
    CANCEL = 2


class BetOutcome(IntEnum):
    UNKNOWN = -1
    NA = 0
    WIN = 1
    HALF_WIN = 2
    PUSH = 3
    HALF_LOSS = 4
    LOSS = 5
    CASHOUT = 6


class Persistence(object):
    LAPSE = 'lapse'
    PERSIST = 'persist'


class OrderSide(object):
    BUY = 'buy'
    SELL = 'sell'


class OrderType(object):
    LIMIT = 'limit'
    MARKET = 'market'
    # MarketWithLeftOverAsLimit
    STOP = 'stop'  # A Stop Loss Market order.
    STOP_LIMIT = 'stop_limit'  # A Stop Loss Limit order
    MARKET_IF_TOUCHED = 'market_if_touched'  # A Take Profit Market order
    LIMIT_IF_TOUCHED = 'limit_if_touched'  # A Take Profit Limit order


class BetInfo(object):
    """
    Represents latest state for a bet that has been placed, whether it has been accepted,
    the amount placed and the payout on it if known along with the bet information
    """

    def __init__(self, **kw):
        self.id = kw.get('id', '')  # stratagem id as opposed to bookmaker id

        self.sticker = kw['sticker']

        self.order_type = kw.get('order_type', '')
        if len(self.order_type) == 0:
            limit_price = kw.get('price', None)  # limit price or None for market. Order prices are always gross
            if limit_price is not None and limit_price <= 1:
                raise ValueError('Invalid limit price {} for {}, must be > 1'.format(limit_price, self.sticker))
            self.price = limit_price
        else:
            self.price = kw['price']

        self.price_requested = kw.get('price_requested', 0)

        self.size = kw.get('size', 0)  # bet stake always in GBP

        self.matched_odds = kw.get('matched_odds', 0)  # weighted average matched odds

        if 'is_back' in kw and 'side' in kw:
            raise ValueError("Cannot set both is_back and side")
        self.is_back = kw.get('is_back', True)  # back or lay bet
        self.side = kw.get('side', None)  # 'BUY' or 'SELL'
        self.status = kw.get('status', BetStatus.UNKNOWN)
        self.placed_dt = kw.get('placed_dt', None)
        self.settled_dt = kw.get('settled_dt', None)
        self.outcome = kw.get('outcome', BetOutcome.UNKNOWN)
        self.pnl = kw.get('pnl', 0)
        self.gross = kw.get('gross', 0)
        self.commission = kw.get('commission', 0)
        self.details = kw.get('details', {})  # execution layer parameters
        self.sor_codes = kw.get('sor_codes', {})  # Unused, for retro-compatibility only
        self.source = kw.get('source', '')

        # TODO: check if we really want default Instruction TTL
        self.ttl = kw.get('ttl', timedelta(hours=24))
        self.persistence = kw.get('persistence', Persistence.LAPSE)

        self.strategy_run_id = kw['strategy_run_id']
        self.strategy_id = kw.get('strategy_id', '')

        self.trading_user_id = kw.get('trading_user_id', '')
        self.account_id = kw.get('account_id', '')
        self.account_currency = kw.get('currency', '')
        self.exchange_rate = kw.get('exchange_rate', 1.0)
        self.trade_id = kw.get('trade_id', '')

        self.execution_details = kw.get('execution_details', {})

        # needed for market_making
        self.instruction_id = kw.get('instruction_id', '')
        self.matched_amount = kw.get('matched_amount', 0.0)
        self.cancelled_amount = kw.get('cancelled_amount', 0.0)
        self.lapsed_amount = kw.get('lapsed_amount', 0.0)
        self.rejected_amount = kw.get('rejected_amount', 0.0)
        self.is_active = kw.get('is_active', False)
        self.matched_bets = kw.get('matched_bets', [])

        self.initial_image = kw.get('initial_image', False)

    def __repr__(self):
        output = str(self.__class__.__name__) + ': {'
        for k, v in self.__dict__.iteritems():
            output += '{0} ({1}): {2}, '.format(k, v.__class__.__name__, v)
        output += '} '
        return output

    def __str__(self):
        if self.side is None:
            bl = 'B' if self.is_back else 'L'
        else:
            bl = 'B' if self.side == 'BUY' else 'S'

        if len(self.instruction_id):
            id_str = 'instr_%s' % self.instruction_id
        else:
            id_str = 'order_%s' % self.id

        str_ = str(self.__class__.__name__) + ':%s:%s:%s%.2f(%.2f)@%.3f(%.3f):%s:bet_%s%s' % (
            self.status.name, self.sticker, bl, self.size, self.matched_amount, self.price, self.matched_odds,
            id_str, self.execution_details.get('bookmaker', ''), self.execution_details.get('bet_id', -1))

        # if is settled
        extras = ''
        if self.settled_dt is not None:
            extras += 'order_id:%s trading_user_id:%s pnl:%.2f gross:%.2f commission:%.2f' % (self.id,
                                                                                              self.trading_user_id,
                                                                                              self.pnl,
                                                                                              self.gross,
                                                                                              self.commission)

        if len(extras):
            str_ += ',%s' % extras

        return str_

    def in_limit(self, best_back, best_lay):
        return ((self.is_back and best_back is not None and self.price <= best_back) or
                (not self.is_back and best_lay is not None and self.price >= best_lay))

    @property
    def active_size(self):
        return self.size - self.matched_amount if self.status in OPEN_BET_STATUSES else 0.0

    @property
    def matched_liability(self):
        # liability is negative
        if self.settled_dt:
            return 0.
        if self.is_back:
            return self.matched_amount * -1.
        else:
            return (self.matched_odds - 1.) * self.matched_amount * -1.


class BetTransaction(object):
    """Single transaction (PLACE/CANCEL/REPLACE) representation.

    Attributes:
        type (TransactionType): TransactionType: PLACE/CANCEL/REPLACE.
        info (BetInfo): Bet details.
        size (float): Only in CANCEL/REPLACE transactions, represents size to CANCEL or new size to REPLACE current one.
        price (float): Only in REPLACE transactions, represents new price to REPLACE current one.
    """

    def __init__(self, trans_type, info, size=None, price=None, bookmakers=None, instructionless=False):
        self.type = trans_type
        self.info = info
        self.size = size
        self.price = price
        self.bookmakers = bookmakers
        self.instructionless = instructionless

    def __repr__(self):
        output = str(self.__class__.__name__) + ': {'
        for k, v in self.__dict__.iteritems():
            output += '{0} ({1}): {2}, '.format(k, v.__class__.__name__, repr(v))
        output += '} '
        return output

    def __str__(self):
        str_ = str(self.__class__.__name__) + ':%s(%s)' % (self.type.name, str(self.info))

        extras = ''
        if self.size is not None:
            extras += 's%.2f' % self.size
        if self.price is not None:
            extras += 'p%.3f' % self.price
        if self.bookmakers is not None:
            extras += 'bm%s' % self.bookmakers

        if len(extras):
            str_ += ',%s' % extras

        return str_


Order = BetInfo
OrderStatus = BetStatus
OrderTransactionType = BetTransactionType
OrderOutcome = BetOutcome
OrderTransaction = BetTransaction


class InstructionStatus(IntEnum):
    """
    These are the states used in realtime, please note that in historical testing the states are the same
    but have slightly different meanings.
    """
    UNKNOWN = -1
    PROCESSING = 1  # Some orders are open in some exchange.
    WATCHING = 2  # Initial status for every sor_code. for sorLimitSnipe this means it is watching the market.
    IDLE = 3  # No active orders in any exchange, the instruction is not going to place any more order.
    CLOSED = 4  # Instruction fully matched, cancelled or ttl expired
    FAILED = 5  # Failure occurred. It has no matched volume.


class InstructionTransactionType(IntEnum):
    PLACE = 0
    CANCEL = 1
    REPLACE = 2
    RESET = 3
    START_SOR_CODE = 4


class Instruction(object):
    def __init__(self, **kw):
        self.id = kw.get('id', '')

        self.sticker = kw['sticker']

        limit_price = kw.get('price', None)  # limit price or None for market. Instruction prices are always net
        if limit_price is not None and limit_price <= 1:
            raise ValueError('Invalid limit price for {}, must be > 1'.format(self.sticker))
        self.price = limit_price

        self.restrict_to = kw.get('restrict_to', {})
        self.size = kw.get('size', 0)  # bet stake always in GBP
        self.matched_odds = kw.get('matched_odds', 0)  # weighted average matched odds
        if 'is_back' in kw and 'side' in kw:
            raise ValueError("Cannot set both is_back and side")
        self.is_back = kw.get('is_back', True)  # back or lay bet
        self.side = kw.get('side', None)  # 'BUY' or 'SELL'
        self.status = kw.get('status', InstructionStatus.UNKNOWN)
        self.details = kw.get('details', {})  # strategy layer memo
        self.algo_details = kw.get('algo_details', {})  # algo manager parameters
        self.sor_codes = kw.get('sor_codes', {})
        self.dt = kw.get('dt', None)

        self.ttl = kw.get('ttl', timedelta(hours=24))
        self.persistence = kw.get('persistence', Persistence.LAPSE)

        self.strategy_run_id = kw['strategy_run_id']
        self.strategy_id = kw.get('strategy_id', '')

        self.trading_user_id = kw.get('trading_user_id', '')
        self.account_id = kw.get('account_id', '')
        self.account_currency = kw.get('currency', '')
        self.exchange_rate = kw.get('exchange_rate', 1.0)
        self.trade_id = kw.get('trade_id', '')

        self.matched_amount = kw.get('matched_amount', 0.0)
        # active amount is the non matched amount in any order that could potentially still match
        self.active_amount = kw.get('active_amount', 0.0)

        # the max size a SOR code can trade
        self.target_size = kw.get('target_size', self.size)

        self.initial_image = kw.get('initial_image', False)  # True if this is a restart

    def __repr__(self):
        output = str(self.__class__.__name__) + ': {'
        for k, v in self.__dict__.iteritems():
            output += '{0} ({1}): {2}, '.format(k, v.__class__.__name__, v)
        output += '} '
        return output

    def __str__(self):
        if self.side is None:
            bl = 'B' if self.is_back else 'L'
        else:
            bl = 'B' if self.side == 'BUY' else 'S'
        return str(self.__class__.__name__) + ':%s:%s:%s%.3f/%.3f(%.3f)@%.3f(%.3f):id_%s' % (
            self.status.name, self.sticker, bl, self.target_size, self.size, self.matched_amount, self.price,
            self.matched_odds, self.id)

    def in_limit(self, best_back, best_lay):
        return ((self.is_back and best_back is not None and self.price <= best_back) or
                (not self.is_back and best_lay is not None and self.price >= best_lay))


class InstructionTransaction(object):
    def __init__(self,
                 trans_type,
                 instruction,
                 size=None,
                 target_size=None,
                 price=None,
                 sor_codes=None,
                 ttl=None,
                 force=False,
                 bookmakers=None):
        """
        :param force: if False only IDLE instruction can be replaced. If TRUE can also replace WATCHING and PROCESSING
        """
        self.type = trans_type
        self.instruction = instruction
        self.size = size
        self.target_size = target_size
        self.price = price
        self.sor_codes = sor_codes
        self.ttl = ttl
        self.force = force
        self.bookmakers = bookmakers

    def __repr__(self):
        output = str(self.__class__.__name__) + ': {'
        for k, v in self.__dict__.iteritems():
            output += '{0} ({1}): {2}, '.format(k, v.__class__.__name__, repr(v))
        output += '} '
        return output

    def __str__(self):
        str_ = str(self.__class__.__name__) + ':%s(%s)' % (self.type.name, str(self.instruction))
        extras = ''
        if self.target_size is not None:
            extras += 'ts%.3f' % self.target_size
        if self.size is not None:
            extras += 's%.3f' % self.size
        if self.price is not None:
            extras += 'p%.3f' % self.price
        if self.sor_codes is not None:
            extras += 'sor%s' % self.sor_codes
        if self.bookmakers is not None:
            extras += 'bm%s' % self.bookmakers
        if self.ttl is not None:
            extras += 'ttl%s' % self.ttl

        if len(extras):
            str_ += ',%s' % extras

        return str_
